#include "demo.hpp"
#include "PhysicalMemory.hpp"

static
PVOID
MemMem (
    const void* SearchBase,
    SIZE_T SearchSize,
    const void* Pattern,
    SIZE_T PatternSize,
    SIZE_T Alignment
    )
{
    if (PatternSize > SearchSize)
    {
        return nullptr;
    }

    Alignment = (Alignment == 0) ? 1 : Alignment;

    auto searchBase = static_cast<const char*>(SearchBase);
    for (SIZE_T i = 0; i <= SearchSize - PatternSize; i += Alignment)
    {
        if (!memcmp(Pattern, &searchBase[i], PatternSize))
        {
            return const_cast<char*>(&searchBase[i]);
        }
    }
    return nullptr;
}

class MemoryScanner
{
public:
    NTSTATUS
    Initialize (
        const PhysicalMemory& Pm
        );

    ULONG64
    Scan (
        ULONG64 ScanBase,
        SIZE_T ScanLength,
        const void* Pattern,
        SIZE_T PatternLength,
        SIZE_T Alignment
        ) const;

    ~MemoryScanner (
        );

private:
    const PhysicalMemory* m_Pm;
    mutable PVOID m_ScanBuffer;
};

NTSTATUS
MemoryScanner::Initialize (
    const PhysicalMemory& Pm
    )
{
    NTSTATUS status;
    PVOID scanBuffer;

    scanBuffer = ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag);
    if (scanBuffer == nullptr)
    {
        DEMO_ERROR("Memory allocation failed");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = STATUS_SUCCESS;
    m_Pm = &Pm;
    m_ScanBuffer = scanBuffer;

Exit:
    return status;
}

ULONG64
MemoryScanner::Scan (
    ULONG64 ScanBase,
    SIZE_T ScanLength,
    const void* Pattern,
    SIZE_T PatternLength,
    SIZE_T Alignment
    ) const
{
    for (ULONG64 pageOffset = 0; pageOffset < ScanLength; pageOffset += PAGE_SIZE)
    {
        NTSTATUS status;
        PVOID found;

        status = m_Pm->Read(m_ScanBuffer, ScanBase + pageOffset, PAGE_SIZE);
        if (!NT_SUCCESS(status))
        {
            //
            // Noisy. Try the next segment.
            //
            //DEMO_ERROR("Read failed : %08x", status);
            break;
        }

        found = MemMem(m_ScanBuffer, PAGE_SIZE, Pattern, PatternLength, Alignment);
        if (found != nullptr)
        {
            ULONG64 byteOffset;

            byteOffset = reinterpret_cast<ULONG64>(found) - reinterpret_cast<ULONG64>(m_ScanBuffer);
            return ScanBase + pageOffset + byteOffset;
        }
    }
    return 0;
}

MemoryScanner::~MemoryScanner (
    )
{
    if (m_ScanBuffer != nullptr)
    {
        ExFreePoolWithTag(m_ScanBuffer, k_PoolTag);
    }
}

static
NTSTATUS
FindSmmCorePrivateData (
    const MemoryScanner& Scanner,
    PULONG64 SmmcAddress
    )
{
    static UNICODE_STRING key =
        RTL_CONSTANT_STRING(L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP\\System Resources\\Loader Reserved");
    static OBJECT_ATTRIBUTES attributes =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&key, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE);
    static UNICODE_STRING valueName = RTL_CONSTANT_STRING(L".Raw");

    NTSTATUS status;
    HANDLE keyHandle;
    PKEY_VALUE_FULL_INFORMATION buffer;
    ULONG resultLength;
    CM_RESOURCE_LIST* list;

    *SmmcAddress = 0;
    buffer = nullptr;

    status = ZwOpenKey(&keyHandle, KEY_ALL_ACCESS, &attributes);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("SetWriteDestination failed : %08x", status);
        goto Exit;
    }

    buffer = static_cast<PKEY_VALUE_FULL_INFORMATION>(
        ExAllocatePoolWithTag(PagedPool, PAGE_SIZE, k_PoolTag));
    if (buffer == nullptr)
    {
        DEMO_ERROR("ExAllocatePoolWithTag failed");
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    status = ZwQueryValueKey(keyHandle,
                             &valueName,
                             KeyValueFullInformation,
                             buffer,
                             PAGE_SIZE,
                             &resultLength);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("ZwQueryValueKey failed : %08x", status);
        goto Exit;
    }

    list = reinterpret_cast<CM_RESOURCE_LIST*>(Add2Ptr(buffer, buffer->DataOffset));
    for (ULONG64 i = 0; i < list->Count; ++i)
    {
        PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;

        fullDescriptor = &list->List[i];
        for (ULONG64 j = 0; j < fullDescriptor->PartialResourceList.Count; ++j)
        {
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
            ULONG64 foundAddress;

            partial = &fullDescriptor->PartialResourceList.PartialDescriptors[j];
            if ((partial->Type != CmResourceTypeMemory) ||
                (partial->Flags != CM_RESOURCE_PORT_MEMORY))
            {
                DEMO_ERROR("Unexpected entry");
                continue;
            }

            static const ULONG64 smmcSignature = 'cmms';
            foundAddress = Scanner.Scan(partial->u.Memory.Start.QuadPart,
                                        partial->u.Memory.Length,
                                        &smmcSignature,
                                        sizeof(smmcSignature),
                                        sizeof(smmcSignature));
            if (foundAddress != 0)
            {
                *SmmcAddress = foundAddress;
                status = STATUS_SUCCESS;
                goto Exit;
            }
        }
    }

    status = STATUS_NOT_FOUND;

Exit:
    if (buffer != nullptr)
    {
        ExFreePoolWithTag(buffer, k_PoolTag);
    }
    if (keyHandle != nullptr)
    {
        ZwClose(keyHandle);
    }
    return status;
}

NTSTATUS
FindSystemManagementServiceTable (
    const PhysicalMemory& Pm,
    PULONG64 SmstAddress
    )
{
    NTSTATUS status;
    ULONG64 smmcAddress;
    ULONG64 smstAddress;
    MemoryScanner scanner;

    status = scanner.Initialize(Pm);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Initialize failed : %08x", status);
        goto Exit;
    }

    status = FindSmmCorePrivateData(scanner, &smmcAddress);
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("LoadLoaderReservedRawData failed : %08x", status);
        goto Exit;
    }
    DEMO_INFO("SMM core found at 0x%llx in RT Code", smmcAddress);

    status = Pm.Read(&smstAddress, smmcAddress + 0x30, sizeof(smstAddress));
    if (!NT_SUCCESS(status))
    {
        DEMO_ERROR("Read failed : %08x", status);
        goto Exit;
    }

    DEMO_INFO("SMST found at 0x%llx in SMRAM", smstAddress);
    *SmstAddress = smstAddress;

Exit:
    return status;
}
